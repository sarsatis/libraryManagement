post {
        success {
            script {
                // Fetch the latest commit SHA for the PR
                def response = sh(script: "curl -s -H \"Authorization: token ${env.GITHUB_TOKEN}\" https://api.github.com/repos/${env.REPO_OWNER}/${env.REPO_NAME}/pulls/${env.PR_NUMBER}", returnStdout: true).trim()
                def json = readJSON text: response
                def commitSha = json.head.sha
                
                // Update the status for the commit
                def statusPayload = """{
                    "state": "success",
                    "description": "Build succeeded",
                    "context": "continuous-integration/jenkins"
                }"""
                sh "curl -X POST -H \"Authorization: token ${env.GITHUB_TOKEN}\" -d '${statusPayload}' https://api.github.com/repos/${env.REPO_OWNER}/${env.REPO_NAME}/statuses/${commitSha}"
            }
        }
        failure {
            script {
                // Fetch the latest commit SHA for the PR
                def response = sh(script: "curl -s -H \"Authorization: token ${env.GITHUB_TOKEN}\" https://api.github.com/repos/${env.REPO_OWNER}/${env.REPO_NAME}/pulls/${env.PR_NUMBER}", returnStdout: true).trim()
                def json = readJSON text: response
                def commitSha = json.head.sha
                
                // Update the status for the commit
                def statusPayload = """{
                    "state": "failure",
                    "description": "Build failed",
                    "context": "continuous-integration/jenkins"
                }"""
                sh "curl -X POST -H \"Authorization: token ${env.GITHUB_TOKEN}\" -d '${statusPayload}' https://api.github.com/repos/${env.REPO_OWNER}/${env.REPO_NAME}/statuses/${commitSha}"
            }
        }
    }
}

---
pipeline {
    agent any
    environment {
        GITHUB_TOKEN = credentials('github-token-id') // GitHub token stored in Jenkins credentials
    }
    stages {
        stage('Fetch PR Labels') {
            steps {
                script {
                    def prNumber = env.ghprbPullId
                    def repo = 'owner/repository'
                    def response = sh(script: "curl -s -H \"Authorization: token ${env.GITHUB_TOKEN}\" -H \"Accept: application/vnd.github.v3+json\" https://api.github.com/repos/${repo}/issues/${prNumber}/labels", returnStdout: true).trim()
                    def labels = readJSON(text: response)
                    def appName = labels.find { it.name.startsWith('appname:') }?.name?.split(': ')[1]
                    def releaseName = labels.find { it.name.startsWith('releaseName:') }?.name?.split(': ')[1]
                    
                    if (!appName || !releaseName) {
                        error("Required labels not found.")
                    }
                    
                    env.ACTUATOR_ENDPOINT = "https://sitsasasasaasas/${appName}/v1.0/actuator/health"
                    env.RELEASE_NAME = releaseName
                    
                    echo "Labels for PR #${prNumber}: ${labels*.name.join(', ')}"
                    echo "ACTUATOR_ENDPOINT: ${env.ACTUATOR_ENDPOINT}"
                    echo "RELEASE_NAME: ${env.RELEASE_NAME}"
                }
            }
        }
        stage('Check Actuator Health') {
            steps {
                withCredentials([
                    file(credentialsId: 'tls-crt-id', variable: 'TLS_CRT_PATH'),
                    file(credentialsId: 'tls-key-id', variable: 'TLS_KEY_PATH')
                ]) {
                    sh """
                    chmod +x path/to/your/script.sh
                    path/to/your/script.sh \$TLS_CRT_PATH \$TLS_KEY_PATH \$ACTUATOR_ENDPOINT \$RELEASE_NAME
                    """
                }
            }
        }
        // Other stages...
    }
}

---
pipeline {
    agent any
    environment {
        GITHUB_TOKEN = credentials('github-token-id') // GitHub token stored in Jenkins credentials
    }
    stages {
        stage('Fetch PR Labels') {
            steps {
                script {
                    def prNumber = env.ghprbPullId
                    def repo = 'owner/repository'
                    def response = sh(script: "curl -s -H \"Authorization: token ${env.GITHUB_TOKEN}\" -H \"Accept: application/vnd.github.v3+json\" https://api.github.com/repos/${repo}/issues/${prNumber}/labels", returnStdout: true).trim()
                    def labels = readJSON(text: response)
                    echo "Labels for PR #${prNumber}: ${labels*.name.join(', ')}"
                }
            }
        }
        // Other stages...
    }
}

---------------------
#!/bin/bash

# Actuator health endpoint (assuming it's exposed via a service)
ACTUATOR_ENDPOINT="http://your-canary-service/actuator/health"

# Polling interval (in seconds)
POLL_INTERVAL=30

# Maximum runtime (in seconds)
MAX_RUNTIME=900

# Function to check actuator health
check_actuator_health() {
  RESPONSE=$(curl -s $ACTUATOR_ENDPOINT)
  STATUS=$(echo $RESPONSE | grep -o '"status":"[^"]*"' | grep -o '[^"]*$')
  
  if [ "$STATUS" == "UP" ]; then
    return 0
  else
    return 1
  fi
}

# Polling loop with timer
start_time=$(date +%s)

while true; do
  echo "Checking actuator health..."
  
  if check_actuator_health; then
    echo "Actuator is up and healthy."
    break
  else
    echo "Actuator is not up yet. Waiting..."
    sleep $POLL_INTERVAL
  fi
  
  # Check elapsed time
  current_time=$(date +%s)
  elapsed_time=$((current_time - start_time))
  
  if [ $elapsed_time -ge $MAX_RUNTIME ]; then
    echo "Maximum runtime exceeded. Exiting..."
    exit 1
  fi
done

echo "Canary instance is healthy. Proceeding with BDD tests."
exit 0

----------------------

pipeline {
    agent any
    environment {
        ACTUATOR_ENDPOINT = "https://your-canary-service/actuator/health"
    }
    stages {
        stage('Wait for Canary Pods') {
            steps {
                script {
                    // Fetch the certificate and key from Jenkins credentials
                    withCredentials([string(credentialsId: 'SIT_TLS_CRT', variable: 'CERT_CONTENT'),
                                     string(credentialsId: 'SIT_TLS_KEY', variable: 'KEY_CONTENT')]) {

                        // Write the certificate and key to the specified paths
                        writeFile file: 'path/tls.crt', text: CERT_CONTENT
                        writeFile file: 'path/tls.key', text: KEY_CONTENT

                        def pollScript = """
                        #!/bin/bash
                        ACTUATOR_ENDPOINT="${env.ACTUATOR_ENDPOINT}"
                        CERT_PATH="path/tls.crt"
                        KEY_PATH="path/tls.key"
                        POLL_INTERVAL=30

                        check_actuator_health() {
                            echo "Polling Actuator Endpoint: \$ACTUATOR_ENDPOINT"
                            CURL_COMMAND="curl -s --cert \$CERT_PATH --key \$KEY_PATH \$ACTUATOR_ENDPOINT"
                            echo "Formed Request: \$CURL_COMMAND"
                            RESPONSE=\$(\$CURL_COMMAND)
                            STATUS=\$(echo \$RESPONSE | grep -o '"status":"[^"]*"' | grep -o '[^"]*\$')
                            echo "Response: \$RESPONSE"
                            echo "Parsed Status: \$STATUS"
                            if [ "\$STATUS" == "UP" ]; then
                                return 0
                            else
                                return 1
                            fi
                        }

                        while true; do
                            echo "Checking actuator health..."
                            if check_actuator_health; then
                                echo "Actuator is up and healthy."
                                break
                            else
                                echo "Actuator is not up yet. Waiting..."
                                sleep \$POLL_INTERVAL
                            fi
                        done

                        echo "Canary instance is healthy. Proceeding with BDD tests."
                        exit 0
                        """
                        writeFile file: 'pollActuatorHealth.sh', text: pollScript
                        sh 'chmod +x pollActuatorHealth.sh'
                        sh './pollActuatorHealth.sh'
                    }
                }
            }
        }
        stage('Run BDD Tests') {
            steps {
                echo 'Running BDD tests...'
                // Add your steps to run BDD tests here
            }
        }
    }
}

----

#!/bin/bash
ACTUATOR_ENDPOINT="$1"
CERT_PATH="$2"
KEY_PATH="$3"
POLL_INTERVAL=30

check_actuator_health() {
    echo "Polling Actuator Endpoint: $ACTUATOR_ENDPOINT"
    CURL_COMMAND="curl -s --cert $CERT_PATH --key $KEY_PATH $ACTUATOR_ENDPOINT"
    echo "Formed Request: $CURL_COMMAND"
    RESPONSE=$($CURL_COMMAND)
    STATUS=$(echo $RESPONSE | grep -o '"status":"[^"]*"' | grep -o '[^"]*$')
    echo "Response: $RESPONSE"
    echo "Parsed Status: $STATUS"
    if [ "$STATUS" == "UP" ]; then
        return 0
    else
        return 1
    fi
}

while true; do
    echo "Checking actuator health..."
    if check_actuator_health; then
        echo "Actuator is up and healthy."
        break
    else
        echo "Actuator is not up yet. Waiting..."
        sleep $POLL_INTERVAL
    fi
done

echo "Canary instance is healthy. Proceeding with BDD tests."
exit 0

pipeline {
    agent any
    environment {
        ACTUATOR_ENDPOINT = "https://your-canary-service/actuator/health"
    }
    stages {
        stage('Wait for Canary Pods') {
            steps {
                script {
                    // Fetch the certificate and key from Jenkins credentials
                    withCredentials([string(credentialsId: 'SIT_TLS_CRT', variable: 'CERT_CONTENT'),
                                     string(credentialsId: 'SIT_TLS_KEY', variable: 'KEY_CONTENT')]) {

                        // Write the certificate and key to the specified paths
                        writeFile file: 'path/tls.crt', text: CERT_CONTENT
                        writeFile file: 'path/tls.key', text: KEY_CONTENT

                        // Write the poll script to the workspace
                        writeFile file: 'pollActuatorHealth.sh', text: libraryResource('path/to/pollActuatorHealth.sh')
                        sh 'chmod +x pollActuatorHealth.sh'

                        // Execute the poll script
                        sh './pollActuatorHealth.sh "${env.ACTUATOR_ENDPOINT}" "path/tls.crt" "path/tls.key"'
                    }
                }
            }
        }
        stage('Run BDD Tests') {
            steps {
                echo 'Running BDD tests...'
                // Add your steps to run BDD tests here
            }
        }
    }
}


----

pipeline {
    agent any
    environment {
        GITHUB_TOKEN = credentials('github-token-id') // GitHub token stored in Jenkins credentials
    }
    stages {
        stage('Fetch PR Labels') {
            steps {
                script {
                    def prNumber = env.ghprbPullId
                    def repo = 'owner/repository'
                    def response = sh(script: "curl -s -H \"Authorization: token ${env.GITHUB_TOKEN}\" -H \"Accept: application/vnd.github.v3+json\" https://api.github.com/repos/${repo}/issues/${prNumber}/labels", returnStdout: true).trim()
                    def labels = readJSON(text: response)
                    
                    // Ensure there are exactly 4 labels
                    if (labels.size() != 4) {
                        error("Expected exactly 4 labels, but found ${labels.size()}.")
                    }
                    
                    // Extract appName and releaseName from labels
                    def appNameLabel = labels.find { it.name.startsWith('appname:') }
                    def releaseNameLabel = labels.find { it.name.startsWith('releaseName:') }
                    
                    if (!appNameLabel || !releaseNameLabel) {
                        error("Required labels not found.")
                    }
                    
                    def appName = appNameLabel.name.split(': ')[1]
                    def releaseName = releaseNameLabel.name.split(': ')[1]
                    
                    // Read the YAML file
                    def appConfig = readYaml file: 'path/to/app_config.yaml'
                    def serviceConfig = appConfig.services[appName]
                    
                    // Check if appName exists in YAML
                    if (!serviceConfig) {
                        error("Appname '${appName}' not found in YAML configuration. Stopping pipeline execution.")
                    }
                    
                    def contextPath = serviceConfig.context_path
                    
                    env.ACTUATOR_ENDPOINT = "https://your-canary-service${contextPath}"
                    env.RELEASE_NAME = releaseName
                    
                    echo "Labels for PR #${prNumber}: ${labels*.name.join(', ')}"
                    echo "ACTUATOR_ENDPOINT: ${env.ACTUATOR_ENDPOINT}"
                    echo "RELEASE_NAME: ${env.RELEASE_NAME}"
                }
            }
        }
        stage('Check Actuator Health') {
            when {
                expression { return env.ACTUATOR_ENDPOINT != null }
            }
            steps {
                withCredentials([
                    file(credentialsId: 'tls-crt-id', variable: 'TLS_CRT_PATH'),
                    file(credentialsId: 'tls-key-id', variable: 'TLS_KEY_PATH')
                ]) {
                    sh """
                    chmod +x path/to/your/script.sh
                    path/to/your/script.sh \$TLS_CRT_PATH \$TLS_KEY_PATH \$ACTUATOR_ENDPOINT \$RELEASE_NAME
                    """
                }
            }
        }
        // Other stages...
    }
}



